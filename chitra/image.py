# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_image.ipynb (unless otherwise specified).

__all__ = ['DATA_FORMATS', 'DEFAULT_MODE', 'read_image', 'resize_image', 'Chitra']

# Cell
import os
from io import BytesIO
from typing import Union

import matplotlib.pyplot as plt
import numpy as np
import requests
import tensorflow as tf
import torch
from PIL import Image

# Cell
from typing import List, Union

DATA_FORMATS = Union[str, Image.Image, np.ndarray, tf.Tensor, torch.Tensor]
DEFAULT_MODE = os.environ.get("CHITRA_DEFAULT_MODE", "TF")

# Cell
def read_image(path: str, channels: int = 3):
    """Reads an image file from the path and return the rgb image in tf.Tensor format."""
    img: tf.Tensor = tf.io.read_file(path)
    img: tf.Tensor = tf.io.decode_image(img, channels=channels, expand_animations=False)
    return img


def resize_image(image: tf.Tensor, size: Union[tf.Tensor, tuple], **kwargs):
    """Resize image to the target `size`: Union[tf.Tensor, tuple]"""
    assert isinstance(
        image, tf.Tensor
    ), f"image must be of type tf.Tensor but passed {type(image)}"
    assert isinstance(size, (tuple, tf.Tensor))
    method = kwargs.get("method", "bilinear")
    return tf.image.resize(image, size, method)


def _url_to_image(url: str) -> Image.Image:
    """returns Image from url"""
    assert url.lower().startswith("http"), "invalid url, must start with http"
    content = requests.get(url).content
    image = Image.open(BytesIO(content))
    return image

# Cell
class Chitra:
    """An ultimate class for Image"""

    def __init__(self, data, *args, **kwargs):
        super().__init__()
        self.image = self._load_image(data)

    def _load_image(self, data: DATA_FORMATS):
        if isinstance(data, Image.Image):
            return data

        if isinstance(data, (tf.Tensor, torch.Tensor)):
            data = data.numpy()

        if isinstance(data, str):
            if data.startswith("http"):
                image = _url_to_image(data)
            else:
                image = Image.open(data)

        elif isinstance(data, np.ndarray):
            image = Image.fromarray(data)

        else:
            raise UserWarning("unable to load image!")

        return image

    def numpy(self):
        return np.asarray(self.image)

    def to_tensor(self, mode: str = DEFAULT_MODE):
        """mode: tf/torch/pt"""
        mode = mode.upper()
        np_image = self.numpy()
        tensor = None

        if mode == "TF":
            tensor = tf.constant(np_image)
        elif mode in ("TORCH", "PT"):
            tensor = torch.from_numpy(np_image)
        else:
            raise UserWarning("invalid mode!")
        return tensor

    @property
    def shape(self):
        return self.numpy().shape

    @property
    def size(self):
        return self.image.size

    def imshow(self, cmap=plt.cm.Blues, *args, **kwargs):
        plt.imshow(self.numpy(), cmap, *args, **kwargs)
